#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2005;
const int Q = 1e9 + 7;
struct Point {
    LL x , y;
    Point () {}
    Point (LL _x , LL _y) {
        x = _x , y = _y;
    }
    Point operator + (const Point& R) const {
        return Point(x + R.x , y + R.y);
    }
    Point operator - (const Point& R) const {
        return Point(x - R.x , y - R.y);
    }
    LL operator ^ (const Point& R) const {
        return x * R.y - y * R.x;
    }
    LL operator % (const Point& R) const {
        return x * R.x + y * R.y;
    }
    bool operator == (const Point& R) const {
        return (*this ^ R) == 0;
    }
    int quad() const {
        if (x > 0 && y >= 0) return 0;
        if (x <= 0 && y > 0) return 1;
        if (x < 0 && y <= 0) return 2;
        if (x >= 0 && y < 0) return 3;
        return -1;
    }
    LL len() const {
        return x * x + y * y;
    }
};

bool cmp(const Point& A , const Point& B) {
    static int x = A.quad() , y = B.quad();
    if (x != y) return x < y;
    static LL Cross = A ^ B;
    if (Cross) return Cross > 0;
    return A.len() < B.len();
}

int n , m;
Point p[N];
LL power[N];
void work() {
    int i , j , x , y , z;
    scanf("%d",&n);
    power[0] = 1;
    for (i = 0 ; i < n ; ++ i) {
        scanf("%d%d" , &x , &y);
        p[i] = Point(x , y);
        power[i + 1] = power[i] * 2 % Q;
    }
    LL res = 0;
    for (i = 0 ; i < n ; ++ i) {
        LL factor = 1;
        vector<Point> V;
        for (j = 0 ; j < n ; ++ j) {
            Point Vec = p[j] - p[i];
            if (!Vec.x && !Vec.y) {
                if (j < i) {
                    factor *= 2;
                    factor %= Q;
                }
            } else {
                V.push_back(Vec);
            }
        }
        if (V.empty()) {
            printf("%d\n" , (int)power[n] - 1);
            return;
        }
        sort(V.begin() , V.end() , cmp);
        m = V.size();
        int P1 = -1 , P2 = -1 , P3 = -1 , P4 = -1;
        for (j = 0 ; j < m ; ++ j) {
            LL C = V[0] ^ V[j];
            if (C > 0 && !~P1) P1 = j;
            if (C >= 0 && !~P2) P2 = j;
            if (C < 0 && !~P3) P3 = j;
            if (C <= 0 && !~P4) P4 = j;            
        }
        if (!~P1) P1 = m;
        if (!~P2) P2 = m;
        if (!~P3) P3 = m;
        if (!~P4) P4 = m;                
        LL delta = 0;
        for (j = 0 ; j < m ; ++ j) {
            Point Vec = V[j];
            printf("%d\n" , j);
            while (P1 < m && (Vec ^ V[(j + P1) % m]) <= 0)
                ++ P1;
            while (P4 < m && (Vec ^ V[(j + P4) % m]) < 0)
                ++ P4;
            while (P3 < m && (Vec ^ V[(j + P3) % m]) >= 0)
                ++ P3;
            while (P2 < m && (Vec ^ V[(j + P2) % m]) > 0)
                ++ P2;
            printf("%d %d %d %d\n" , P1 , P2 , P3 , P4);
            x = P2 - P1;
            y = P4 - P3;
            z = j + n - P4;
            delta += (power[x] + power[y] - 1) * power[z] % Q;
            delta %= Q;
            if (P1 == m) P1 = 0;
            if (P2 == m) P2 = 0;
            if (P3 == m) P3 = 0;
            if (P4 == m) P4 = 0;            
            if (P1) -- P1; if (P2) -- P2;
            if (P3) -- P3; if (P4) -- P4;            
        }
        res += delta * factor % Q;
        res %= Q;    
    }
    cout << res << endl;
    
}

int main() {
    work();    
    return 0;
}
